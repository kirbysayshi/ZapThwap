<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-type" content="text/html; charset=utf-8">
		<title>ZAP - Spatial Hashing Test</title>
	</head>
	<body>
		<canvas id="cvsWorld" width="600" height="600" style="background-color: black;"></canvas>
		<div id="info"></div>
		<div id="tsInfo"></div>
		<script type="text/javascript" src="../../lib/jquery-1.4.2.min.js"></script>
		
		<script src="../../zap/hsh.js" type="text/javascript" charset="utf-8"></script>
		<script type="text/javascript">
var  $cWorld = $("#cvsWorld")
	,info = $("#info")[0]
	,tsInfo = $("#tsInfo")[0]
	,tsStats = {}
	,ctx = $cWorld[0].getContext('2d')
	,candidates
	,twoBodies = [
		 new Vertex({
			name: 'left', x: 0, y: 0, radius: 50
		})
		,new Vertex({
			name: 'right', x: 50, y: 0, radius: 50
		})
	]
	,twoTestPoint = [80, 0]
	,threeBodies = [
		 new Vertex({
			name: 'left', x: 100, y: 100, radius: 10
		})
		,new Vertex({
			name: 'middle', x: 150, y: 150, radius: 100
		})
		,new Vertex({
			name: 'right', x: 200, y: 100, radius: 10
		})
	]
	,threeTestPoint = [5, 0]
	,maxBodies = 2
	,maxRadius = 600
	,minRadius = 1
	,minDim = [-100, -100, 0]
	,maxDim = [700, 700, 0]
	,randomBodies = []
	,randomTestPoints = []
	,leftToSpawn = maxBodies;

//resetSpatialHash();
//mapScene(twoBodies);
//candidates = findCandidatesForPoint(twoTestPoint);

//areEqual('twoBodies', candidates.length, 2);
//twoBodies.forEach(function(e){ e.draw(ctx, 'rgba(142,142,142,0.5)'); });
//drawPoint(twoTestPoint[0], twoTestPoint[1]);
//drawHGrid(ctx, [0,0,0], [1000,1000,0]);



//resetSpatialHash();
//mapScene(threeBodies);
//candidates = findCandidatesForPoint(threeTestPoint);

//areEqual('threeBodies', candidates.length, 3);
//threeBodies.forEach(function(e){ e.draw(ctx, 'rgba(142,142,142,0.5)'); });
//drawPoint(threeTestPoint[0], threeTestPoint[1]);
//drawHGrid(ctx, [0,0,0], [1000,1000,0]);


resetSpatialHash();

while(leftToSpawn > 0){
	randomBodies.push(
		new Vertex({
			name: '', 
			x: (Math.random() * (maxDim[0] - minDim[0])) + minDim[0], 
			y: (Math.random() * (maxDim[1] - minDim[1])) + minDim[1], 
			radius: (Math.random() * (maxRadius - minRadius)) + minRadius
		})
	);
	leftToSpawn -= 1;
}


var iterations = 10;

// HSH scene

mapScene(randomBodies);
var candidatesCount = [];
var candidates = [];
var avgCandidatesPerRun = 0;
var minMaxCandidates = [maxBodies,0]
var avgCollisions = 0;

var start = +new Date();
for(var i = 0; i < iterations; i++){
	mapScene(randomBodies);
	//collide everything
	candidates = [];
	for(var j = 0; j < maxBodies; j++){
		var body1 = randomBodies[j];
		var colliding = [];
		var cs = findCandidatesForPoint([body1.x, body1.y]);
		candidatesCount.push(cs.length);
		for(var l = 0; l < cs.length; l++){
			var body2 = cs[l];
			var dist2 = body1.x*body2.x + body1.y*body2.y;
			if(dist2 < (body1.radius+body2.radius)*(body1.radius+body2.radius)){
				//bCandidates.push(body2);
				avgCollisions += 1;
			}
		}
	}
	var total = 0;
	for(var k = 0; k < maxBodies; k++){
		total += candidatesCount[k];
		minMaxCandidates[0] = Math.min(candidatesCount[k], minMaxCandidates[0]);
		minMaxCandidates[1] = Math.max(candidatesCount[k], minMaxCandidates[1]);
	}
	
	avgCandidatesPerRun += total;
}
var end = +new Date();
console.log('map avg time: ' + ((end - start) / iterations) + 'ms');
console.log('avg candidates per run: ' + (avgCandidatesPerRun / iterations));
console.log('min/max candidates: ' + minMaxCandidates[0] + '/' + minMaxCandidates[1]);
console.log('avg collisions: ' + (avgCollisions / iterations));


drawHGrid(ctx, [0,0,0], [1000,1000,0]);
randomBodies.forEach(function(e){ e.draw(ctx, 'rgba(255,255,255,0.5)'); });

// brute force scene
var candidates = [];
var avgCandidatesPerRun = 0;
var minMaxCandidates = [maxBodies, 0];
for(var i = 0; i < iterations; i++){
	mapScene(randomBodies);
	//collide everything
	candidates = [];
	for(var j = 0; j < maxBodies; j++){
		var body1 = randomBodies[j];
		var bCandidates = []
		for(var l = j+1; l < maxBodies; l++){
			var body2 = randomBodies[l];
			var dist2 = body1.x*body2.x + body1.y*body2.y;
			if(dist2 < (body1.radius+body2.radius)*(body1.radius+body2.radius)){
				bCandidates.push(body2);
			}
		}
		candidates.push(bCandidates.length);
	}
	var total = 0;
	for(var k = 0; k < maxBodies; k++){
		total += candidates[k];
		minMaxCandidates[0] = Math.min(candidates[k], minMaxCandidates[0]);
		minMaxCandidates[1] = Math.max(candidates[k], minMaxCandidates[1]);
	}
	
	avgCandidatesPerRun += total;
}
var end = +new Date();

console.log('brute avg time: ' + ((end - start) / iterations) + 'ms');
console.log('avg candidates per run: ' + (avgCandidatesPerRun / iterations));
console.log('min/max candidates: ' + minMaxCandidates[0] + '/' + minMaxCandidates[1]);

function areEqual(name, a, b){
	if( a !== b){
		console.error(name + ' FAILURE. ' + a + ' and ' + b + ' are not equal.');
	} else {
		console.log(name + ' a: ' + a + ' b: ' + b);
	}
}

function drawPoint(x, y, color){
	ctx.beginPath();
	ctx.fillStyle = 'rgba(142,142,255,0.5)';
	ctx.arc( x, y, 10, 0, Math.PI*2, false);
	ctx.fill();
}
		</script>
	</body>
</html>