<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-type" content="text/html; charset=utf-8">
		<title>ZAP - Spatial Hashing Test</title>
	</head>
	<body>
		<canvas id="cvsWorld" width="600" height="600" style="background-color: black;"></canvas>
		<div id="info"></div>
		<div id="tsInfo"></div>
		<script type="text/javascript" src="../../lib/jquery-1.4.2.min.js"></script>
		
		<script src="../../zap/HSHG.js" type="text/javascript" charset="utf-8"></script>
		<script type="text/javascript">

// used to outline the interface th HSHG expects
function Vertex(args /*x, y, radius*/){
	var argProp;

	for(argProp in args){
		if(args.hasOwnProperty(argProp)){
			this[ argProp ] = args[argProp]; 
		}
	}
}

Vertex.prototype.getAABB = function(){
	var rad = this.radius
		,x = this.x
		,y = this.y;
	return this.aabb = { 
		 min: [ x - rad, y - rad ]
		,max: [ x + rad, y + rad ]
	};
}

Vertex.prototype.draw = function(ctx, color){
	ctx.strokeStyle = color;
	ctx.beginPath();
	ctx.arc( this.x, this.y, this.radius, 0, Math.PI*2, false);
	ctx.strokeRect(this.aabb.min[0], this.aabb.min[1], this.radius*2, this.radius*2);
	ctx.stroke();
}


var  $cWorld = $("#cvsWorld")
	,info = $("#info")[0]
	,tsInfo = $("#tsInfo")[0]
	,tsStats = {}
	,ctx = $cWorld[0].getContext('2d')
	,candidates
	,twoBodies = [
		 new Vertex({
			name: 'left', x: 0, y: 0, radius: 50
		})
		,new Vertex({
			name: 'right', x: 50, y: 0, radius: 50
		})
	]
	,twoTestPoint = [80, 0]
	,threeBodies = [
		 new Vertex({
			name: 'left', x: 100, y: 100, radius: 10
		})
		,new Vertex({
			name: 'middle', x: 150, y: 150, radius: 100
		})
		,new Vertex({
			name: 'right', x: 200, y: 100, radius: 10
		})
	]
	,oneHundredVs = (function(){
		var i = 0, vs = [];
		for(; i < 50; i++){
			vs.push(new Vertex({
				name: i, x: 18*i, y: 10, radius: 10
			}));
		}
		
		for(i = 0; i < 50; i++){
			vs.push(new Vertex({
				name: i, x: (70+50)*i, y: 100, radius: 50
			}));
		}
		
		return vs;
	})()
	,threeTestPoint = [5, 0]
	,maxBodies = 2
	,maxRadius = 600
	,minRadius = 1
	,minDim = [-100, -100, 0]
	,maxDim = [700, 700, 0]
	,randomBodies = []
	,randomTestPoints = []
	,leftToSpawn = maxBodies;

//resetSpatialHash();
//mapScene(twoBodies);
//candidates = findCandidatesForPoint(twoTestPoint);

//areEqual('twoBodies', candidates.length, 2);
//twoBodies.forEach(function(e){ e.draw(ctx, 'rgba(142,142,142,0.5)'); });
//drawPoint(twoTestPoint[0], twoTestPoint[1]);
//drawHGrid(ctx, [0,0,0], [1000,1000,0]);



//resetSpatialHash();
//mapScene(threeBodies);
//candidates = findCandidatesForPoint(threeTestPoint);

//areEqual('threeBodies', candidates.length, 3);
//threeBodies.forEach(function(e){ e.draw(ctx, 'rgba(142,142,142,0.5)'); });
//drawPoint(threeTestPoint[0], threeTestPoint[1]);
//drawHGrid(ctx, [0,0,0], [1000,1000,0]);

HSHG.reset();
HSHG.mapScene( oneHundredVs );
var p = HSHG._private();
console.log(p);
HSHG.drawGrid(ctx, [0,0], [1000,1000]);
oneHundredVs.forEach(function(e){ e.draw(ctx, 'rgba(142,142,142,0.5)'); });
testCollisions( p.hash, oneHundredVs );


function areEqual(name, a, b){
	if( a !== b){
		console.error(name + ' FAILURE. ' + a + ' and ' + b + ' are not equal.');
	} else {
		console.log(name + ' a: ' + a + ' b: ' + b);
	}
}

function drawPoint(x, y, color){
	ctx.beginPath();
	ctx.fillStyle = 'rgba(142,142,255,0.5)';
	ctx.arc( x, y, 10, 0, Math.PI*2, false);
	ctx.fill();
}

function testCollisions(hash, allBodies){
	var ib = 0, iv1 = 0, iv2 = 0, bucket, v1, v2
		,collisions = [], overkill = [], hashCollisionCount = 0, bruteCollisionCount = 0
		,diffX, diffY, dist, radius2;

	for(; ib < hash.length; ib++){
		if(collisions[ib] == undefined) collisions[ib] = 0;
		if(overkill[ib] == undefined) overkill[ib] = [];
		bucket = hash[ib];
		if(bucket !== undefined)
		for(iv1 = 0; iv1 < bucket.length; iv1++){
			v1 = bucket[iv1];
			for(iv2 = iv1+1; iv2 < bucket.length; iv2++){
				v2 = bucket[iv2];
				diffX = v2.x - v1.x;
				diffY = v2.y - v1.y;
				dist = Math.sqrt(diffX*diffX + diffY*diffY);
				radius2 = (v1.radius+v2.radius);
				if( dist < radius2 ){
					collisions[ib] += 1;
					hashCollisionCount += 1;
				} else if ( dist > radius2 * 1.2){
					overkill[ib].push(dist);
				}
			}
		}
	}
	
	console.log(collisions);
	console.log(overkill);
	
	console.log('hashed collisions detected: ' + hashCollisionCount);
	
	var total = 0;
	overkill.forEach(function(obj){
		total += obj.length;
	});
	console.log('total overkill: ' + total);
	
	for(iv1 = 0; iv1 < allBodies.length; iv1++){
		v1 = allBodies[iv1];
		for(iv2 = iv1+1; iv2 < allBodies.length; iv2++){
			v2 = allBodies[iv2];
			
			diffX = v2.x - v1.x;
			diffY = v2.y - v1.y;
			dist = Math.sqrt(diffX*diffX + diffY*diffY);
			radius2 = (v1.radius+v2.radius);
			if( dist < radius2 ){
				bruteCollisionCount += 1;
			}
		}
	}
	
	console.log('brute collisions detected: ' + bruteCollisionCount);
}
		</script>
	</body>
</html>